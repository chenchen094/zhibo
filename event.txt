//@version=6
indicator("BBRSI Pro (BTC+ETH) â€¢ 2m + CN Time", shorttitle="BBRSI Pro 2m CN", overlay=true, max_labels_count=500)

// ========= ä»…åœ¨ 2 åˆ†é’Ÿä¸‹å¯ç”¨è®¡ç®—/æ¨é€ =========
isTwoMinute = timeframe.isminutes and timeframe.multiplier == 2
calcEnabled = isTwoMinute

// ================= å‚æ•° =================
bb_length  = input.int(14, "Bollinger Length", minval=5)
bb_mult    = input.float(2.0, "Bollinger StdDev", minval=0.5, maxval=10)
rsiLength  = input.int(11, "RSI Length", minval=1)
rsiUpper   = input.int(75, "RSI Upper Level", minval=51, maxval=99)
rsiLower   = input.int(25, "RSI Lower Level", minval=1,  maxval=49)
dFilter    = input.bool(true, "Use Directional Filter")
fastTyp    = input.string("EMA", "Fast MA Type", options=["SMA","EMA","WMA","VWMA","SMMA","DEMA","TEMA","HullMA","ZEMA","TMA","SSMA"])
fastLen    = input.int(50, "Fast - Length", minval=1)
slowTyp    = input.string("EMA", "Slow MA Type", options=["SMA","EMA","WMA","VWMA","SMMA","DEMA","TEMA","HullMA","ZEMA","TMA","SSMA"])
slowLen    = input.int(200, "Slow - Length", minval=1)
dCandles   = input.int(3, "Candles to test Market Direction", minval=2)
resoln_    = input.float(0.0, "Candle body past BB boundary (ticks)", minval=0)

// ç»Ÿè®¡å‚æ•°ï¼ˆåŸºäº 2 åˆ†é’Ÿï¼‰
holdMins = input.int(10, "ç»“æœç»Ÿè®¡æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰", minval=1)
tfSec    = 120
holdBars = math.max(1, math.round(holdMins * 60 / tfSec))

// æœ¬æ ¹Kçº¿â€œæ”¶ç›˜æ—¶åˆ»â€çš„æ—¶é—´æˆ³ï¼ˆæ¯«ç§’ï¼‰
barCloseTs = time + tfSec * 1000

// æ–‡æ¡ˆï¼šå›ºå®šæ˜¾ç¤ºâ€œ2 åˆ†é’Ÿâ€
tfText = "2 åˆ†é’Ÿ"

// ===== æ ‡è®°å¼€å…³ï¼ˆæ–°å¢ï¼šå…¥åœºç®­å¤´ï¼‰ =====
group_marks = "Markers"
showEntryArrows = input.bool(true, "æ˜¾ç¤ºå…¥åœºç®­å¤´(CALLâ†‘ / PUTâ†“)", group=group_marks)

// ===== åŒæ—¶ç›‘æ§â€œäºŒé¥¼â€ï¼ˆETHï¼‰å¼€å…³ä¸è®¾ç½® =====
monitorEth  = input.bool(true, "åŒæ—¶ç›‘æ§äºŒé¥¼(ETH)")
ethSymbol   = input.symbol("BINANCE:ETHUSDT", "äºŒé¥¼åˆçº¦ä»£ç ")
workTfInput = input.timeframe("", "äºŒé¥¼ä¿¡å·å‘¨æœŸï¼ˆç•™ç©º=2mï¼‰")
workTf      = workTfInput == "" ? "2" : workTfInput  // é»˜è®¤ 2 åˆ†é’Ÿ

// ================= å®‰å…¨ MA å˜ä½“ =================
maVariant(maType, src, len) =>
    sma_  = ta.sma(src, len)
    ema1  = ta.ema(src, len)
    ema2  = ta.ema(ema1, len)
    dema_ = 2.0 * ema1 - ema2
    tema_ = 3.0 * (ema1 - ema2) + ta.ema(ema2, len)
    hull_ = ta.wma(2.0 * ta.wma(src, math.round(len / 2.0)) - ta.wma(src, len), math.round(math.sqrt(len)))
    tma_  = ta.sma(ta.sma(src, len), len)
    zema_ = ema1 + (ema1 - ema2)
    switch maType
        "EMA"     => ema1
        "SMA"     => sma_
        "WMA"     => ta.wma(src, len)
        "VWMA"    => ta.vwma(src, len)
        "SMMA"    => ta.rma(src, len)
        "DEMA"    => dema_
        "TEMA"    => tema_
        "HullMA"  => hull_
        "ZEMA"    => zema_
        "TMA"     => tma_
        "SSMA"    => ema1
        => sma_

// ================= ä¸»ä½“è®¡ç®—ï¼ˆå¤§é¥¼=å½“å‰å›¾ï¼‰ =================
SlowEMA = maVariant(slowTyp, close, slowLen)
FastEMA = maVariant(fastTyp,  close, fastLen)

// â€”â€”æŠ½å‡º rising / fallingï¼Œé¿å…ä¸€è‡´æ€§æŠ¥é”™
isUpTrend   = ta.rising(SlowEMA, dCandles) and FastEMA > SlowEMA
isDownTrend = ta.falling(SlowEMA, dCandles) and FastEMA < SlowEMA
mDirection  = isUpTrend ? 1 : isDownTrend ? -1 : 0

plot(SlowEMA, "SlowEMA", color=color.red,   linewidth=2)
plot(FastEMA, "FastEMA", color=color.olive, linewidth=2)

point  = syminfo.mintick
resoln = point * resoln_

rsiVal  = ta.rsi(close, rsiLength)
bbBasis = ta.sma(close, bb_length)
dev     = ta.stdev(close, bb_length)
bbHigh  = bbBasis + bb_mult * dev
bbLow   = bbBasis - bb_mult * dev

plot(bbBasis, "Basis Line", color=color.new(color.navy, 50))
ubo = plot(bbHigh, "Upper Band", color=color.new(color.blue, 20))
lbo = plot(bbLow,  "Lower Band", color=color.new(color.blue, 20))
fill(ubo, lbo, color=color.new(color.gray, 80))

rsiRange   = rsiVal > rsiLower and rsiVal < rsiUpper
FastWarnHi = ((close > open) and (not dFilter or mDirection < 0)) ? rsiRange and (close > bbHigh + resoln) : false
FastWarnLo = ((close < open) and (not dFilter or mDirection > 0)) ? rsiRange and (close < bbLow  - resoln) : false

FastBreakHi = ((not dFilter or mDirection < 0) and FastWarnHi[1] and (not FastWarnHi)) ? rsiRange and (close[1] >= bbHigh[1] + resoln) : false  // PUT
FastBreakLo = ((not dFilter or mDirection > 0) and FastWarnLo[1] and (not FastWarnLo)) ? rsiRange and (close[1] <= bbLow[1]  - resoln) : false  // CALL

// é¢„è­¦/çªç ´å½¢çŠ¶ï¼ˆä¿ç•™ï¼‰
plotshape(FastWarnHi, title="BB High Warning", style=shape.diamond, color=color.fuchsia, location=location.abovebar, size=size.tiny)
plotshape(FastWarnLo, title="BB Low  Warning", style=shape.diamond, color=color.fuchsia, location=location.belowbar, size=size.tiny)
plotshape(FastBreakHi, title="BB High Alert PUT",  style=shape.triangledown, color=color.red,   text="PUT",  location=location.abovebar)
plotshape(FastBreakLo, title="BB Low  Alert CALL", style=shape.triangleup,   color=color.green, text="CALL", location=location.belowbar)

// ===== æ–°å¢ï¼šå…¥åœºç®­å¤´ï¼ˆæŒ‡å‘å½“å‰ä¿¡å· K çº¿ï¼‰ =====
plotshape(calcEnabled and showEntryArrows and FastBreakLo, title="CALL Entry Arrow",
     style=shape.arrowup,   location=location.belowbar, size=size.large, color=color.new(color.lime, 0), text="CALL")
plotshape(calcEnabled and showEntryArrows and FastBreakHi, title="PUT Entry Arrow",
     style=shape.arrowdown, location=location.abovebar, size=size.large, color=color.new(color.red, 0),  text="PUT")

// ================= å·¥å…·ï¼šåŒ—äº¬æ—¶é—´ =================
fmtCN(ts) => str.format("{0,time,yyyy-MM-dd HH:mm:ss}", ts, "Asia/Shanghai")

// ================= å¤§é¥¼ç»Ÿè®¡ï¼ˆé€’æ¨ç´¯è®¡ï¼‰ =================
callSig   = FastBreakLo
putSig    = FastBreakHi
callEntry = callSig ? close : na
putEntry  = putSig  ? close : na

callDoneNow = callSig[holdBars]
putDoneNow  = putSig[holdBars]
callEntryN  = callEntry[holdBars]
putEntryN   = putEntry[holdBars]
callWinNow  = callDoneNow and close > callEntryN
putWinNow   = putDoneNow  and close < putEntryN

var int callTotal = 0
var int callWins  = 0
var int putTotal  = 0
var int putWins   = 0

isOK       = barstate.isconfirmed and calcEnabled
callTotal := nz(callTotal[1]) + (isOK and callDoneNow ? 1 : 0)
putTotal  := nz(putTotal[1])  + (isOK and putDoneNow  ? 1 : 0)
callWins  := nz(callWins[1])  + (isOK and callWinNow  ? 1 : 0)
putWins   := nz(putWins[1])   + (isOK and putWinNow   ? 1 : 0)

strWR(wins, total) => total > 0 ? str.tostring(math.round(100 * wins / total, 1)) + "%" : "-"




// ================= äºŒé¥¼ï¼ˆETHï¼‰ä¿¡å·ä¸ç»Ÿè®¡ =================
f_calc_sig() =>
    slow = maVariant(slowTyp, close, slowLen)
    fast = maVariant(fastTyp, close, fastLen)
    upT = ta.rising(slow, dCandles) and fast > slow
    dnT = ta.falling(slow, dCandles) and fast < slow
    md  = upT ? 1 : dnT ? -1 : 0

    rsiV = ta.rsi(close, rsiLength)
    bbB  = ta.sma(close, bb_length)
    dv   = ta.stdev(close, bb_length)
    bbH  = bbB + bb_mult * dv
    bbL  = bbB - bb_mult * dv

    rOK  = rsiV > rsiLower and rsiV < rsiUpper
    fwH  = ((close > open) and (not dFilter or md < 0)) ? rOK and (close > bbH) : false
    fwL  = ((close < open) and (not dFilter or md > 0)) ? rOK and (close < bbL) : false
    fbH  = ((not dFilter or md < 0) and fwH[1] and (not fwH)) ? rOK and (close[1] >= bbH[1]) : false
    fbL  = ((not dFilter or md > 0) and fwL[1] and (not fwL)) ? rOK and (close[1] <= bbL[1]) : false

    [fbL, fbH, close, time_close]

// é€šè¿‡ request.security è·å–äºŒé¥¼ä¿¡å·ï¼ˆé»˜è®¤ 2mï¼‰
var bool  callSigE = false
var bool  putSigE  = false
var float closeE   = na
var int   tE       = na
if monitorEth
    [_callE, _putE, _closeE, _tE] = request.security(ethSymbol, workTf, f_calc_sig())
    callSigE := _callE
    putSigE  := _putE
    closeE   := _closeE
    tE       := _tE

// å…¥åœºæ¨é€ï¼ˆäºŒé¥¼ï¼‰
if monitorEth and calcEnabled
    symName = str.replace(ethSymbol, "BINANCE:", "")
    if barstate.isconfirmed and callSigE
        alert('{"msgtype":"text","text":{"content":"äºŒé¥¼äº‹ä»¶\\nåˆçº¦ï¼š' + symName +
              '\\nå½“å‰ä»·æ ¼ï¼š' + str.tostring(closeE) +
              '\\næ—¶é—´ï¼š' + fmtCN(tE) +
              '\\nå½“å‰Kçº¿ï¼š' + tfText +
              '\\nä¿¡å·ï¼šæ¶¨ğŸ“ˆï¼ˆCALLï¼‰"}}', alert.freq_once_per_bar_close)
    if barstate.isconfirmed and putSigE
        alert('{"msgtype":"text","text":{"content":"äºŒé¥¼äº‹ä»¶\\nåˆçº¦ï¼š' + symName +
              '\\nå½“å‰ä»·æ ¼ï¼š' + str.tostring(closeE) +
              '\\næ—¶é—´ï¼š' + fmtCN(tE) +
              '\\nå½“å‰Kçº¿ï¼š' + tfText +
              '\\nä¿¡å·ï¼šè·ŒğŸ“‰ï¼ˆPUTï¼‰"}}', alert.freq_once_per_bar_close)

// ç»“æœè¯„ä¼°ä¸æ¨é€ï¼ˆäºŒé¥¼ï¼Œé€’æ¨ç´¯è®¡ï¼‰
var int callTotalE = 0
var int callWinsE  = 0
var int putTotalE  = 0
var int putWinsE   = 0

if monitorEth and calcEnabled
    callEntryE = callSigE ? closeE : na
    putEntryE  = putSigE  ? closeE : na

    callDoneNowE = callSigE[holdBars]
    putDoneNowE  = putSigE[holdBars]
    callEntryNE  = callEntryE[holdBars]
    putEntryNE   = putEntryE[holdBars]
    callWinNowE  = callDoneNowE and closeE > callEntryNE
    putWinNowE   = putDoneNowE  and closeE < putEntryNE

    if barstate.isconfirmed
        callTotalE := nz(callTotalE[1]) + (callDoneNowE ? 1 : 0)
        putTotalE  := nz(putTotalE[1])  + (putDoneNowE  ? 1 : 0)
        callWinsE  := nz(callWinsE[1])  + (callWinNowE  ? 1 : 0)
        putWinsE   := nz(putWinsE[1])   + (putWinNowE   ? 1 : 0)

        symName     = str.replace(ethSymbol, "BINANCE:", "")

        if callDoneNowE
            alert('{"msgtype":"text","text":{"content":"äºŒé¥¼äº‹ä»¶ï¼ˆç»Ÿè®¡ï¼‰\\nç±»å‹ï¼šCALL ' + (callWinNowE ? 'èµ¢ âœ…' : 'äº âŒ') +
                  '\\nåˆçº¦ï¼š' + symName +
                  '\\nå…¥åœºä»·ï¼š' + str.tostring(callEntryNE) + 'ï¼ˆ' + fmtCN(tE[holdBars]) + 'ï¼‰' +
                  '\\nåˆ°æœŸä»·ï¼š' + str.tostring(closeE)      + 'ï¼ˆ' + fmtCN(tE) + 'ï¼‰' +
                  '\\nå½“å‰Kçº¿ï¼š' + tfText + '"}}', alert.freq_once_per_bar)

        if putDoneNowE
            alert('{"msgtype":"text","text":{"content":"äºŒé¥¼äº‹ä»¶ï¼ˆç»Ÿè®¡ï¼‰\\nç±»å‹ï¼šPUT ' + (putWinNowE ? 'èµ¢ âœ…' : 'äº âŒ') +
                  '\\nåˆçº¦ï¼š' + symName +
                  '\\nå…¥åœºä»·ï¼š' + str.tostring(putEntryNE) + 'ï¼ˆ' + fmtCN(tE[holdBars]) + 'ï¼‰' +
                  '\\nåˆ°æœŸä»·ï¼š' + str.tostring(closeE)     + 'ï¼ˆ' + fmtCN(tE) + 'ï¼‰' +
                  '\\nå½“å‰Kçº¿ï¼š' + tfText + '"}}', alert.freq_once_per_bar)

// ================= ï¼ˆå›¾ä¸Šï¼‰èƒœç‡è¡¨æ ¼ï¼šBTC / ETH / æ€» =================
callWR_B = callTotal  > 0 ? 100.0 * callWins  / callTotal  : na
putWR_B  = putTotal   > 0 ? 100.0 * putWins   / putTotal   : na
allTot_B = callTotal + putTotal
allWin_B = callWins  + putWins
allWR_B  = allTot_B  > 0 ? 100.0 * allWin_B  / allTot_B    : na

callWR_E = monitorEth and callTotalE > 0 ? 100.0 * callWinsE / callTotalE : na
putWR_E  = monitorEth and putTotalE  > 0 ? 100.0 * putWinsE  / putTotalE  : na
allTot_E = monitorEth ? callTotalE + putTotalE : na
allWin_E = monitorEth ? callWinsE  + putWinsE  : na
allWR_E  = monitorEth and allTot_E > 0 ? 100.0 * allWin_E / allTot_E : na

// æ€»è®¡ï¼ˆBTC+ETHï¼‰
callWinsAll  = callWins + (monitorEth ? callWinsE : 0)
callTotalAll = callTotal + (monitorEth ? callTotalE : 0)
putWinsAll   = putWins  + (monitorEth ? putWinsE  : 0)
putTotalAll  = putTotal + (monitorEth ? putTotalE : 0)
allTot_All   = (callTotal + putTotal) + (monitorEth ? (callTotalE + putTotalE) : 0)
allWin_All   = (callWins  + putWins ) + (monitorEth ? (callWinsE  + putWinsE ) : 0)

callWR_All  = callTotalAll > 0 ? 100.0 * callWinsAll / callTotalAll : na
putWR_All   = putTotalAll  > 0 ? 100.0 * putWinsAll  / putTotalAll  : na
allWR_All   = allTot_All   > 0 ? 100.0 * allWin_All  / allTot_All   : na

// é 2 åˆ†é’Ÿæç¤º
if barstate.islast and not calcEnabled
    label.new(bar_index, high, "âš  è¯·å°†å›¾è¡¨å‘¨æœŸåˆ‡æ¢ä¸º 2 åˆ†é’Ÿ\nè„šæœ¬å·²æš‚åœç»Ÿè®¡ä¸æ¨é€", style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))

// ================= æ¡ä»¶æé†’ï¼ˆå…¼å®¹è€ç”¨æ³•ï¼‰ =================
alertcondition(FastBreakHi, title="PUT (close)",  message="PUT")
alertcondition(FastBreakLo, title="CALL (close)", message="CALL")