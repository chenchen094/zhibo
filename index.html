<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
    <title>Binance 实时行情 · H5</title>
    <style>
        :root {
            --bg: #0b1220;
            --panel: #0f1a2b;
            --panel2: #0c1526;
            --txt: #e7ecf3;
            --muted: #8aa1c8;
            --up: #2bd17e;
            --down: #ff5d5d;
            --accent: #4cc9f0;
            --radius: 16px;
            --pad: clamp(12px, 2.5vw, 18px);
            --fs-title: clamp(15px, 1.8vw, 18px);
            --fs-price: clamp(22px, 5vw, 30px);
            --fs-body: clamp(12px, 1.4vw, 14px);
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            background: radial-gradient(1200px 600px at 20% -10%, #13233d 0%, #0b1220 60%), #0b1220;
            color: var(--txt);
            font: var(--fs-body)/1.45 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial;
            -webkit-font-smoothing: antialiased;
            -webkit-tap-highlight-color: transparent;
        }

        .app {
            min-height: 100dvh;
            /* 移动端更可靠的视口高度 */
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            display: flex;
            flex-direction: column;
        }

        header {
            position: sticky;
            top: 0;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--pad);
            gap: 10px;
            border-bottom: 1px solid #1c2941;
            background: linear-gradient(180deg, #0f1a2b 0%, #0b1220 100%);
        }

        header h1 {
            margin: 0;
            font-size: var(--fs-title);
            font-weight: 700;
            letter-spacing: .3px
        }

        header .right {
            display: flex;
            align-items: center;
            gap: 10px
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #999;
            box-shadow: 0 0 10px currentColor;
            flex: 0 0 auto
        }

        .dot.on {
            background: #20e3b2;
            color: #20e3b2
        }

        .dot.off {
            background: #ff5d5d;
            color: #ff5d5d
        }

        .conn {
            color: var(--muted)
        }

        button {
            appearance: none;
            border: 1px solid #244875;
            background: #142b4a;
            color: #cfe1ff;
            padding: 10px 14px;
            border-radius: 12px;
            min-height: 44px;
            min-width: 88px;
            font-weight: 600;
            letter-spacing: .2px;
            touch-action: manipulation;
        }

        main {
            padding: var(--pad);
            flex: 1 1 auto
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--pad)
        }

        @media (min-width:600px) {
            .grid {
                grid-template-columns: repeat(2, minmax(260px, 1fr))
            }
        }

        .card {
            background: linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
            border: 1px solid #1b2945;
            border-radius: var(--radius);
            padding: var(--pad);
            box-shadow: 0 8px 30px rgba(0, 0, 0, .25);
            position: relative;
            overflow: hidden;
        }

        .card:before {
            content: "";
            position: absolute;
            inset: -1px -1px auto -1px;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(76, 201, 240, .8), transparent)
        }

        .sym {
            display: flex;
            align-items: center;
            gap: 10px
        }

        .sym h2 {
            margin: 0;
            font-size: clamp(16px, 2.4vw, 20px);
            font-weight: 800;
            letter-spacing: .4px
        }

        .badge {
            font-size: 11px;
            color: #b7c6e6;
            background: #132444;
            border: 1px solid #20406f;
            padding: 2px 6px;
            border-radius: 999px
        }

        .price {
            margin-top: 8px;
            font-size: var(--fs-price);
            font-weight: 900;
            letter-spacing: .4px
        }

        .price.up {
            color: var(--up)
        }

        .price.down {
            color: var(--down)
        }

        .row {
            margin-top: 10px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            color: var(--muted)
        }

        @media (min-width:600px) {
            .row {
                grid-template-columns: repeat(3, 1fr)
            }
        }

        .kv {
            background: #0c1729;
            border: 1px solid #1b2c4c;
            border-radius: 12px;
            padding: 10px
        }

        .kv b {
            display: block;
            color: #cfe1ff;
            font-size: 12px;
            margin-bottom: 4px;
            font-weight: 700
        }

        .kv span {
            font-variant-numeric: tabular-nums
        }

        canvas {
            width: 100%;
            height: 56px;
            background: #0b1324;
            border-radius: 10px;
            margin-top: 12px;
            border: 1px solid #1a2a48
        }

        .pred {
            margin-top: 12px;
            background: #0b162b;
            border: 1px solid #1b2c4c;
            border-radius: 12px;
            padding: 10px;
        }

        .pred .result {
            font-weight: 800;
            margin-bottom: 8px;
        }

        .pred .up {
            color: var(--up)
        }

        .pred .down {
            color: var(--down)
        }

        .pred ul {
            margin: 0;
            padding-left: 18px;
            color: var(--muted);
            display: grid;
            grid-template-columns: 1fr;
            gap: 4px;
        }

        @media (min-width:600px) {
            .pred ul {
                grid-template-columns: repeat(2, 1fr)
            }
        }

        footer {
            padding: 8px var(--pad) 16px;
            color: #7891bb;
            text-align: center;
            font-size: 12px
        }

        .hint {
            color: #98b0db
        }
    </style>
</head>

<body>
    <div class="app">
        <header>
            <h1>Binance 实时行情 · <span class="hint">BTC / ETH</span></h1>
            <div class="right">
                <span id="connDot" class="dot off"></span>
                <span id="connText" class="conn">Disconnected</span>
            </div>
        </header>

        <main>
            <div class="grid">
                <!-- BTC -->
                <div class="card" data-sym="BTCUSDT">
                    <div class="sym">
                        <h2>BTC / USDT</h2><span class="badge">24h Ticker</span>
                    </div>
                    <div class="price" data-field="price">—</div>
                    <div class="row">
                        <div class="kv"><b>涨跌幅</b><span data-field="changeP">—</span></div>
                        <div class="kv"><b>涨跌额</b><span data-field="changeA">—</span></div>
                        <div class="kv"><b>24h 高 / 低</b><span data-field="hl">—</span></div>
                        <div class="kv"><b>成交额(USDT)</b><span data-field="volQ">—</span></div>
                        <div class="kv"><b>更新时间</b><span data-field="time">—</span></div>
                    </div>
                    <canvas data-canvas aria-hidden="true"></canvas>
                    <div class="pred">
                        <div class="result" data-field="predResult">预测：—</div>
                        <ul class="plist">
                            <li data-reason="bb">布林带：—</li>
                            <li data-reason="ma">均线趋势：—</li>
                            <li data-reason="rsi">RSI：—</li>
                            <li data-reason="macd">MACD：—</li>
                            <li data-reason="kdj">KDJ：—</li>
                            <li data-reason="hist">历史胜率：—</li>
                        </ul>
                    </div>
                </div>

                <!-- ETH -->
                <div class="card" data-sym="ETHUSDT">
                    <div class="sym">
                        <h2>ETH / USDT</h2><span class="badge">24h Ticker</span>
                    </div>
                    <div class="price" data-field="price">—</div>
                    <div class="row">
                        <div class="kv"><b>涨跌幅</b><span data-field="changeP">—</span></div>
                        <div class="kv"><b>涨跌额</b><span data-field="changeA">—</span></div>
                        <div class="kv"><b>24h 高 / 低</b><span data-field="hl">—</span></div>
                        <div class="kv"><b>成交额(USDT)</b><span data-field="volQ">—</span></div>
                        <div class="kv"><b>更新时间</b><span data-field="time">—</span></div>
                    </div>
                    <canvas data-canvas aria-hidden="true"></canvas>
                    <div class="pred">
                        <div class="result" data-field="predResult">预测：—</div>
                        <ul class="plist">
                            <li data-reason="bb">布林带：—</li>
                            <li data-reason="ma">均线趋势：—</li>
                            <li data-reason="rsi">RSI：—</li>
                            <li data-reason="macd">MACD：—</li>
                            <li data-reason="kdj">KDJ：—</li>
                            <li data-reason="hist">历史胜率：—</li>
                        </ul>
                    </div>
                </div>
            </div>
        </main>

        <footer>
            数据源：<span class="hint" id="dsHost">binance-proxy-worker.paopaoyudev.workers.dev</span>（Worker 代理，自动回退直连）
        </footer>
    </div>

    <script>
        (() => {
            // ===== 配置 =====
            const SYMBOLS = ['btcusdt', 'ethusdt']; // 需要的交易对
            const STREAMS = [
                ...SYMBOLS.map(s => `${s}@ticker`),
                ...SYMBOLS.map(s => `${s}@kline_1m`)
            ].join('/');

            // 固定使用 Cloudflare Worker 代理（可用 window.BINANCE_PROXY 覆盖）
            const WORKER = (window.BINANCE_PROXY || 'https://binance-proxy-worker.paopaoyudev.workers.dev').replace(/\/$/, '');

            // WS 候选：优先 Worker，其次直连 Binance（兼容少数网络直连可用的情况）
            function wsCandidates(streams) {
                const list = [
                    WORKER.replace(/^https:/, 'wss:') + `/stream?streams=${streams}`,
                    'wss://stream.binance.com:9443/stream?streams=' + streams
                ];
                return Array.from(new Set(list));
            }

            // REST 候选：优先 Worker，其次直连 Binance
            function restCandidates() {
                const list = [
                    WORKER + '/api',
                    'https://api.binance.com/api'
                ];
                return Array.from(new Set(list));
            }

            // ===== DOM 索引 =====
            const connDot = document.getElementById('connDot');
            const connText = document.getElementById('connText');
            const dsEl = document.getElementById('dsHost'); if (dsEl) dsEl.textContent = new URL(WORKER).host;

            const cards = {};
            document.querySelectorAll('.card').forEach(card => {
                const sym = card.dataset.sym;
                cards[sym] = {
                    priceEl: card.querySelector('[data-field="price"]'),
                    pEl: card.querySelector('[data-field="changeP"]'),
                    aEl: card.querySelector('[data-field="changeA"]'),
                    hlEl: card.querySelector('[data-field="hl"]'),
                    volQEl: card.querySelector('[data-field="volQ"]'),
                    timeEl: card.querySelector('[data-field="time"]'),
                    canvas: card.querySelector('[data-canvas]'),
                    series: [],
                    // 新增：预测相关
                    predEl: card.querySelector('[data-field="predResult"]'),
                    reason: {
                        bb: card.querySelector('[data-reason="bb"]'),
                        ma: card.querySelector('[data-reason="ma"]'),
                        rsi: card.querySelector('[data-reason="rsi"]'),
                        macd: card.querySelector('[data-reason="macd"]'),
                        kdj: card.querySelector('[data-reason="kdj"]'),
                        hist: card.querySelector('[data-reason="hist"]'),
                    },
                    ohlc: { o: [], h: [], l: [], c: [] } // 1m K线缓存
                };
            });

            // ===== 工具 =====
            const fmt = (n, d = 2) => (n == null || isNaN(n)) ? '—' :
                Number(n).toLocaleString('en-US', { minimumFractionDigits: d, maximumFractionDigits: d });
            const ts = (ms) => new Date(ms).toLocaleString();

            function drawSpark(sym, price) {
                const c = cards[sym].canvas;
                const ctx = c.getContext('2d');
                const arr = cards[sym].series;
                const maxPoints = 120;

                arr.push(Number(price));
                if (arr.length > maxPoints) arr.shift();

                // DPR 适配
                const dpr = window.devicePixelRatio || 1;
                const w = c.clientWidth, h = c.clientHeight;
                c.width = Math.max(1, w * dpr); c.height = Math.max(1, h * dpr);
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                ctx.clearRect(0, 0, w, h);

                if (arr.length < 2) return;
                const min = Math.min(...arr), max = Math.max(...arr), range = Math.max(1e-9, max - min);

                const grad = ctx.createLinearGradient(0, 0, w, 0);
                grad.addColorStop(0, '#4cc9f0'); grad.addColorStop(1, '#20e3b2');
                ctx.lineWidth = 2; ctx.strokeStyle = grad;

                ctx.beginPath();
                for (let i = 0; i < arr.length; i++) {
                    const x = i / (arr.length - 1) * (w - 10) + 5;
                    const y = h - ((arr[i] - min) / range) * (h - 10) - 5;
                    i ? ctx.lineTo(x, y) : ctx.moveTo(x, y);
                }
                ctx.stroke();
            }

            // ===== 指标计算（简化版，仅用于本地预测） =====
            const last = (arr, n = 0) => arr.length ? arr[arr.length - 1 - n] : undefined;
            const sliceLast = (arr, n) => arr.slice(Math.max(0, arr.length - n));

            const sma = (arr, n) => {
                const a = sliceLast(arr, n);
                if (a.length < n) return null;
                return a.reduce((s, v) => s + Number(v), 0) / n;
            };
            const ema = (arr, n) => {
                if (arr.length < n) return null;
                const k = 2 / (n + 1);
                let e = arr[0];
                for (let i = 1; i < arr.length; i++) e = Number(arr[i]) * k + e * (1 - k);
                return e;
            };
            const stdev = (arr, n) => {
                const a = sliceLast(arr, n);
                if (a.length < n) return null;
                const m = sma(a, n);
                const v = a.reduce((s, v) => s + (v - m) * (v - m), 0) / n;
                return Math.sqrt(v);
            };
            const rsi = (closes, n = 14) => {
                if (closes.length <= n) return null;
                let gains = 0, losses = 0;
                for (let i = closes.length - n; i < closes.length; i++) {
                    const ch = closes[i] - closes[i - 1];
                    if (ch >= 0) gains += ch; else losses -= ch;
                }
                const rs = losses === 0 ? 100 : gains / (losses || 1e-9);
                const val = 100 - 100 / (1 + rs);
                return Math.max(0, Math.min(100, val));
            };
            const macdVals = (closes, f = 12, s = 26, sig = 9) => {
                if (closes.length < s + sig) return null;
                const macdLine = ema(closes, f) - ema(closes, s);
                const signalArr = sliceLast(closes, s + sig);
                // 重新构造 MACD 序列用于 signal 近似
                const series = [];
                for (let i = 0; i < signalArr.length; i++) {
                    const seg = closes.slice(0, closes.length - signalArr.length + i + 1);
                    series.push(ema(seg, f) - ema(seg, s));
                }
                const signal = ema(series, sig);
                return { macd: macdLine, signal, hist: macdLine - signal };
            };
            const kdjVals = (o, h, l, c, n = 9) => {
                if (c.length < n) return null;
                const hh = Math.max(...sliceLast(h, n));
                const ll = Math.min(...sliceLast(l, n));
                const rsv = hh === ll ? 50 : (last(c) - ll) / (hh - ll) * 100;
                // 简化平滑
                const K = 2 / 3 * 50 + 1 / 3 * rsv;
                const D = 2 / 3 * 50 + 1 / 3 * K;
                const J = 3 * K - 2 * D;
                return { K, D, J };
            };
            const boll = (closes, n = 20, mult = 2) => {
                const b = sma(closes, n);
                const sd = stdev(closes, n);
                if (b == null || sd == null) return null;
                return { basis: b, upper: b + mult * sd, lower: b - mult * sd };
            };
            // 最近 N 次“10分钟后涨跌”胜率
            const histWin = (closes, ahead = 10, lookback = 180) => {
                const L = Math.min(lookback, closes.length - (ahead + 1));
                if (L <= 10) return null;
                let up = 0;
                for (let i = closes.length - L - ahead; i < closes.length - ahead; i++) {
                    if (closes[i + ahead] > closes[i]) up++;
                }
                return { total: L, win: up, rate: up / L * 100 };
            };
            async function fetchJSON(url, ms = 8000) {
                const ac = new AbortController();
                const id = setTimeout(() => ac.abort('timeout'), ms);
                try {
                    const r = await fetch(url, { cache: 'no-store', signal: ac.signal });
                    if (!r.ok) throw new Error(`HTTP ${r.status}`);
                    return await r.json();
                } finally {
                    clearTimeout(id);
                }
            }
            // ===== 预取历史K线（启动时一次，填充OHLC缓存，避免“采样不足”） =====
            async function prefill(symU) {
                const baseList = restCandidates();
                const urls = baseList.map(b => `${b}/v3/klines?symbol=${symU}&interval=1m&limit=600`);
                let lastErr = null;
                for (const url of urls) {
                    try {
                        const data = await fetchJSON(url, 8000);
                        const card = cards[symU];
                        if (!card) return false;
                        const ohlc = card.ohlc;
                        ohlc.o = data.map(x => Number(x[1]));
                        ohlc.h = data.map(x => Number(x[2]));
                        ohlc.l = data.map(x => Number(x[3]));
                        ohlc.c = data.map(x => Number(x[4]));
                        computePrediction(symU);
                        console.log('[REST prefill] ok:', symU, url);
                        return true;
                    } catch (e) {
                        lastErr = e;
                        console.warn('[REST prefill] fail:', symU, url, e?.message || e);
                    }
                }
                console.error('[REST prefill] all candidates failed for', symU, lastErr?.message || lastErr);
                return false;
            }

            function computePrediction(sym) {
                const buf = cards[sym].ohlc;
                const c = buf.c;
                if (c.length < 30) { // 数据太少（预取后一般>=600）
                    cards[sym].predEl.textContent = '预测：采样不足（学习中…）';
                    cards[sym].predEl.classList.remove('up', 'down');
                    return;
                }
                // 指标
                const bb = boll(c, 20, 2);
                const ma10 = sma(c, 10), ma20 = sma(c, 20);
                const ma10prev = sma(sliceLast(c, 11).slice(0, 10), 10);
                const rsi14 = rsi(c, 14);
                const macd = macdVals(c);
                const kdj = kdjVals(buf.o, buf.h, buf.l, buf.c, 9);
                const hist = histWin(c, 10, 240);

                let score = 0, maxScore = 0;
                const w = { bb: 2, ma: 1.5, rsi: 1, macd: 1, kdj: 1, hist: 2 };

                // 布林
                if (bb) {
                    let txt = '';
                    if (last(c) > bb.upper) { score -= w.bb; txt = '布林带：价在上轨外，易回落'; }
                    else if (last(c) < bb.lower) { score += w.bb; txt = '布林带：价在下轨外，易反弹'; }
                    else if (last(c) >= bb.basis) { score += w.bb * 0.5; txt = '布林带：位于中轴上方，偏多'; }
                    else { score -= w.bb * 0.5; txt = '布林带：位于中轴下方，偏空'; }
                    cards[sym].reason.bb.textContent = txt;
                    maxScore += w.bb;
                }

                // 均线趋势
                if (ma10 && ma20) {
                    const slope = (ma10prev != null) ? (ma10 - ma10prev) : 0;
                    if (ma10 > ma20 && slope >= 0) { score += w.ma; cards[sym].reason.ma.textContent = '均线：MA10>MA20 且上行'; }
                    else if (ma10 < ma20 && slope <= 0) { score -= w.ma; cards[sym].reason.ma.textContent = '均线：MA10<MA20 且下行'; }
                    else { cards[sym].reason.ma.textContent = '均线：震荡/背离'; }
                    maxScore += w.ma;
                }

                // RSI
                if (rsi14 != null) {
                    if (rsi14 > 70) { score -= w.rsi; cards[sym].reason.rsi.textContent = `RSI：${rsi14.toFixed(1)}（偏热）`; }
                    else if (rsi14 < 30) { score += w.rsi; cards[sym].reason.rsi.textContent = `RSI：${rsi14.toFixed(1)}（偏冷）`; }
                    else if (rsi14 > 55) { score += w.rsi * 0.5; cards[sym].reason.rsi.textContent = `RSI：${rsi14.toFixed(1)}（略多）`; }
                    else if (rsi14 < 45) { score -= w.rsi * 0.5; cards[sym].reason.rsi.textContent = `RSI：${rsi14.toFixed(1)}（略空）`; }
                    else { cards[sym].reason.rsi.textContent = `RSI：${rsi14.toFixed(1)}（中性）`; }
                    maxScore += w.rsi;
                }

                // MACD
                if (macd) {
                    if (macd.hist > 0) { score += w.macd; cards[sym].reason.macd.textContent = 'MACD：柱线>0（偏多）'; }
                    else if (macd.hist < 0) { score -= w.macd; cards[sym].reason.macd.textContent = 'MACD：柱线&lt;0（偏空）'; }
                    else { cards[sym].reason.macd.textContent = 'MACD：中性'; }
                    maxScore += w.macd;
                }

                // KDJ
                if (kdj) {
                    if (kdj.K > kdj.D) { score += w.kdj * 0.6; cards[sym].reason.kdj.textContent = `KDJ：K>D（偏多）`; }
                    else if (kdj.K < kdj.D) { score -= w.kdj * 0.6; cards[sym].reason.kdj.textContent = `KDJ：K&lt;D（偏空）`; }
                    else { cards[sym].reason.kdj.textContent = 'KDJ：中性'; }
                    maxScore += w.kdj;
                }

                // 历史 10 分钟胜率
                if (hist) {
                    const dir = hist.rate >= 50 ? '偏多' : '偏空';
                    cards[sym].reason.hist.textContent = `历史胜率：${hist.rate.toFixed(1)}%（${dir}）`;
                    const adj = (hist.rate - 50) / 50; // -1..1
                    score += w.hist * adj;
                    maxScore += w.hist;
                }

                const up = score >= 0;
                const conf = Math.round(50 + 50 * Math.abs(score) / (maxScore || 1));
                cards[sym].predEl.textContent = `预测：10分钟后${up ? '上涨' : '下跌'} ｜ 置信度 ${conf}%`;
                cards[sym].predEl.classList.toggle('up', up);
                cards[sym].predEl.classList.toggle('down', !up);
            }

            // 画布自适应（旋转/resize）
            const ro = new ResizeObserver(() => {
                Object.keys(cards).forEach(sym => {
                    const arr = cards[sym].series;
                    if (arr.length) drawSpark(sym, arr[arr.length - 1]);
                });
            });
            Object.values(cards).forEach(c => ro.observe(c.canvas));

            // ===== WebSocket（多候选 + 握手超时回退 + 心跳） =====
            let ws = null;
            let alive = false;
            let heartbeat = null;
            let backoff = 1000;

            function setConn(on) {
                alive = on;
                connDot.classList.toggle('on', on);
                connDot.classList.toggle('off', !on);
                connText.textContent = on ? 'Connected' : 'Disconnected';
            }

            // 统一的 WS 消息处理（移动原 onmessage 逻辑到这里）
            function onWSMessage(ev) {
                const payload = JSON.parse(ev.data);    // { stream, data }
                const stream = payload.stream || '';
                // 24h ticker
                if (stream.endsWith('@ticker')) {
                    const d = payload.data;
                    const sym = d.s;
                    const card = cards[sym];
                    if (!card) return;

                    const lastP = d.c, chgA = d.p, chgP = d.P, high = d.h, low = d.l, volQ = d.q, time = d.E;
                    const isUp = Number(chgP) >= 0;

                    card.priceEl.textContent = fmt(lastP, 2);
                    card.priceEl.classList.toggle('up', isUp);
                    card.priceEl.classList.toggle('down', !isUp);
                    card.pEl.textContent = `${fmt(chgP, 2)}%`;
                    card.aEl.textContent = fmt(chgA, 2);
                    card.hlEl.textContent = `${fmt(high, 2)} / ${fmt(low, 2)}`;
                    card.volQEl.textContent = fmt(volQ, 0);
                    card.timeEl.textContent = ts(time);

                    drawSpark(sym, lastP);
                    return;
                }
                // 1m kline（只处理已收盘的）
                if (stream.endsWith('@kline_1m')) {
                    const d = payload.data;
                    const k = d.k;
                    if (!k || !k.x) return;
                    const sym = d.s;
                    const card = cards[sym];
                    if (!card) return;

                    const buf = card.ohlc;
                    buf.o.push(Number(k.o));
                    buf.h.push(Number(k.h));
                    buf.l.push(Number(k.l));
                    buf.c.push(Number(k.c));
                    const maxLen = 600;
                    ['o', 'h', 'l', 'c'].forEach(key => { const a = buf[key]; if (a.length > maxLen) a.splice(0, a.length - maxLen); });
                    computePrediction(sym);
                    return;
                }
            }

            function startHeartbeat() {
                stopHeartbeat();
                heartbeat = setInterval(() => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        try { ws.send('ping'); } catch (_) { }
                    }
                }, 30000);
            }
            function stopHeartbeat() {
                if (heartbeat) { clearInterval(heartbeat); heartbeat = null; }
            }

            const WS_CANDIDATES = wsCandidates(STREAMS);
            let wsIndex = 0;

            function openNext() {
                // 所有候选都失败：指数回退后重试
                if (wsIndex === 0) console.log('[WS candidates]', WS_CANDIDATES);
                if (wsIndex >= WS_CANDIDATES.length) {
                    wsIndex = 0;
                    setTimeout(openNext, backoff);
                    backoff = Math.min(backoff * 2, 15000);
                    return;
                }
                const url = WS_CANDIDATES[wsIndex++];
                tryOpen(url);
            }

            function tryOpen(url) {
                if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;

                const sock = new WebSocket(url);
                ws = sock;
                let opened = false;
                console.log('[WS] dialing:', url);

                // 握手超时（4s）自动切下一个候选，避免“Pending”
                const timer = setTimeout(() => {
                    if (!opened && sock.readyState === WebSocket.CONNECTING) {
                        console.warn('[WS] handshake timeout, fallback next');
                        try { sock.close(); } catch (e) { }
                        openNext();
                    }
                }, 6000);

                sock.onopen = () => {
                    opened = true;
                    clearTimeout(timer);
                    setConn(true);
                    backoff = 1000;
                    startHeartbeat();
                    console.log('[WS] open:', url);
                };

                sock.onmessage = onWSMessage;

                sock.onclose = (ev) => {
                    clearTimeout(timer);
                    stopHeartbeat();
                    setConn(false);
                    console.warn('[WS] closed:', ev.code, ev.reason);
                    openNext();
                };

                sock.onerror = () => {
                    clearTimeout(timer);
                    // 触发 close -> openNext
                    try { sock.close(); } catch (e) { }
                };
            }

            // 先预取历史，再启动 WS（避免刚开页就“采样不足”）
            /* 并行启动：先连 WS，再做 REST 预取（两者互不阻塞） */
            (function boot() {
                // 友好提示
                Object.keys(cards).forEach(symU => {
                    cards[symU].predEl.textContent = '预测：加载历史…';
                    cards[symU].predEl.classList.remove('up', 'down');
                });

                // 1) 立即启动 WS（候选+回退）
                openNext();

                // 2) REST 预取限时执行（不阻塞 WS）
                const tasks = Object.keys(cards).map(sym =>
                    prefill(sym).catch(e => {
                        console.warn('[REST prefill] skip:', sym, e?.message || e);
                        return false;
                    })
                );
                Promise.allSettled(tasks).then(() => console.log('[BOOT] prefill done'));
            })();
        })();
    </script>
</body>

</html>