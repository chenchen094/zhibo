//@version=6
indicator("BBRSI Pro (BTC+ETH) ‚Ä¢ Auto TF + CN Time", shorttitle="BBRSI Pro Auto CN", overlay=true, max_labels_count=500)

// ========= Ë∑üÈöèÂõæË°®Âë®ÊúüÔºà‰∏çÂÜçÈôêÂà∂Âõ∫ÂÆöÂë®ÊúüÔºâ =========
calcEnabled = true

// ================= ÂèÇÊï∞ =================
bb_length  = input.int(14, "Bollinger Length", minval=5)
bb_mult    = input.float(2.0, "Bollinger StdDev", minval=0.5, maxval=10)
rsiLength  = input.int(11, "RSI Length", minval=1)
rsiUpper   = input.int(75, "RSI Upper Level", minval=51, maxval=99)
rsiLower   = input.int(25, "RSI Lower Level", minval=1,  maxval=49)
dFilter    = input.bool(true, "Use Directional Filter")
fastTyp    = input.string("EMA", "Fast MA Type", options=["SMA","EMA","WMA","VWMA","SMMA","DEMA","TEMA","HullMA","ZEMA","TMA","SSMA"])
fastLen    = input.int(50, "Fast - Length", minval=1)
slowTyp    = input.string("EMA", "Slow MA Type", options=["SMA","EMA","WMA","SMMA","DEMA","TEMA","HullMA","ZEMA","TMA","SSMA"])
slowLen    = input.int(200, "Slow - Length", minval=1)
dCandles   = input.int(3, "Candles to test Market Direction", minval=2)
resoln_    = input.float(0.0, "Candle body past BB boundary (ticks)", minval=0)

// ÁªüËÆ°ÂèÇÊï∞ÔºàËá™Âä®ÈöèÂõæË°®Êç¢ÁÆóÔºâ
holdMins = input.int(10, "ÁªìÊûúÁªüËÆ°Êó∂ÈïøÔºàÂàÜÈíüÔºâ", minval=1)
tfSec    = math.max(1, timeframe.in_seconds(timeframe.period))
holdBars = math.max(1, math.round(holdMins * 60 / tfSec))

// ÊñáÊ°àÔºöÊòæÁ§∫‚ÄúX ÂàÜÈíü/Áßí/Â§©/Âë®/Êúà‚Äù
makeTfText() =>
    string tf = timeframe.period
    if timeframe.isseconds
        tf := str.tostring(timeframe.multiplier) + " Áßí"
    else if timeframe.isminutes
        tf := str.tostring(timeframe.multiplier) + " ÂàÜÈíü"
    else if timeframe.isdaily
        tf := str.tostring(timeframe.multiplier) + " Â§©"
    else if timeframe.isweekly
        tf := str.tostring(timeframe.multiplier) + " Âë®"
    else if timeframe.ismonthly
        tf := str.tostring(timeframe.multiplier) + " Êúà"
    tf
tfText = makeTfText()

// ===== ÂêåÊó∂ÁõëÊéß‚Äú‰∫åÈ•º‚ÄùÔºàETHÔºâÂºÄÂÖ≥‰∏éËÆæÁΩÆ =====
monitorEth  = input.bool(true, "ÂêåÊó∂ÁõëÊéß‰∫åÈ•º(ETH)")
ethSymbol   = input.symbol("BINANCE:ETHUSDT", "‰∫åÈ•ºÂêàÁ∫¶‰ª£Á†Å")
// ÁïôÁ©∫Êó∂Ë∑üÈöèÂõæË°®Âë®Êúü
workTfInput = input.timeframe("", "‰∫åÈ•º‰ø°Âè∑Âë®ÊúüÔºàÁïôÁ©∫=ÈöèÂõæË°®Ôºâ")
workTf      = workTfInput == "" ? timeframe.period : workTfInput

// ================= ÂÆâÂÖ® MA Âèò‰Ωì =================
maVariant(maType, src, len) =>
    sma_  = ta.sma(src, len)
    ema1  = ta.ema(src, len)
    ema2  = ta.ema(ema1, len)
    dema_ = 2.0 * ema1 - ema2
    tema_ = 3.0 * (ema1 - ema2) + ta.ema(ema2, len)
    hull_ = ta.wma(2.0 * ta.wma(src, math.round(len / 2.0)) - ta.wma(src, len), math.round(math.sqrt(len)))
    tma_  = ta.sma(ta.sma(src, len), len)
    zema_ = ema1 + (ema1 - ema2)
    switch maType
        "EMA"     => ema1
        "SMA"     => sma_
        "WMA"     => ta.wma(src, len)
        "VWMA"    => ta.vwma(src, len)
        "SMMA"    => ta.rma(src, len)
        "DEMA"    => dema_
        "TEMA"    => tema_
        "HullMA"  => hull_
        "ZEMA"    => zema_
        "TMA"     => tma_
        "SSMA"    => ema1
        => sma_

// ================= ‰∏ª‰ΩìËÆ°ÁÆóÔºàÂ§ßÈ•º=ÂΩìÂâçÂõæÔºâ =================
SlowEMA = maVariant(slowTyp, close, slowLen)
FastEMA = maVariant(fastTyp,  close, fastLen)

// ‚Äî‚ÄîÊäΩÂá∫ rising / fallingÔºåÈÅøÂÖç‰∏ÄËá¥ÊÄßÊä•Èîô
isUpTrend   = ta.rising(SlowEMA, dCandles) and FastEMA > SlowEMA
isDownTrend = ta.falling(SlowEMA, dCandles) and FastEMA < SlowEMA
mDirection  = isUpTrend ? 1 : isDownTrend ? -1 : 0

plot(SlowEMA, "SlowEMA", color=color.red,   linewidth=2)
plot(FastEMA, "FastEMA", color=color.olive, linewidth=2)

point  = syminfo.mintick
resoln = point * resoln_

rsiVal  = ta.rsi(close, rsiLength)
bbBasis = ta.sma(close, bb_length)
dev     = ta.stdev(close, bb_length)
bbHigh  = bbBasis + bb_mult * dev
bbLow   = bbBasis - bb_mult * dev

plot(bbBasis, "Basis Line", color=color.new(color.navy, 50))
ubo = plot(bbHigh, "Upper Band", color=color.new(color.blue, 20))
lbo = plot(bbLow,  "Lower Band", color=color.new(color.blue, 20))
fill(ubo, lbo, color=color.new(color.gray, 80))

rsiRange   = rsiVal > rsiLower and rsiVal < rsiUpper
FastWarnHi = ((close > open) and (not dFilter or mDirection < 0)) ? rsiRange and (close > bbHigh + resoln) : false
FastWarnLo = ((close < open) and (not dFilter or mDirection > 0)) ? rsiRange and (close < bbLow  - resoln) : false

FastBreakHi = ((not dFilter or mDirection < 0) and FastWarnHi[1] and (not FastWarnHi)) ? rsiRange and (close[1] >= bbHigh[1] + resoln) : false  // PUT
FastBreakLo = ((not dFilter or mDirection > 0) and FastWarnLo[1] and (not FastWarnLo)) ? rsiRange and (close[1] <= bbLow[1]  - resoln) : false  // CALL

plotshape(FastWarnHi, title="BB High Warning", style=shape.diamond, color=color.fuchsia, location=location.abovebar, size=size.tiny)
plotshape(FastWarnLo, title="BB Low  Warning", style=shape.diamond, color=color.fuchsia, location=location.belowbar, size=size.tiny)
plotshape(FastBreakHi, title="BB High Alert PUT",  style=shape.triangledown, color=color.red,   text="PUT",  location=location.abovebar)
plotshape(FastBreakLo, title="BB Low  Alert CALL", style=shape.triangleup,   color=color.green, text="CALL", location=location.belowbar)

// ================= Â∑•ÂÖ∑ÔºöÂåó‰∫¨Êó∂Èó¥ =================
fmtCN(ts) => str.format("{0,time,yyyy-MM-dd HH:mm:ss}", ts, "Asia/Shanghai")

// ================= Â§ßÈ•ºÁªüËÆ°ÔºàÈÄíÊé®Á¥ØËÆ°Ôºâ =================
callSig   = FastBreakLo
putSig    = FastBreakHi
callEntry = callSig ? close : na
putEntry  = putSig  ? close : na

callDoneNow = callSig[holdBars]
putDoneNow  = putSig[holdBars]
callEntryN  = callEntry[holdBars]
putEntryN   = putEntry[holdBars]
callWinNow  = callDoneNow and close > callEntryN
putWinNow   = putDoneNow  and close < putEntryN

var int callTotal = 0
var int callWins  = 0
var int putTotal  = 0
var int putWins   = 0

isOK       = barstate.isconfirmed and calcEnabled
callTotal := nz(callTotal[1]) + (isOK and callDoneNow ? 1 : 0)
putTotal  := nz(putTotal[1])  + (isOK and putDoneNow  ? 1 : 0)
callWins  := nz(callWins[1])  + (isOK and callWinNow  ? 1 : 0)
putWins   := nz(putWins[1])   + (isOK and putWinNow   ? 1 : 0)

strWR(wins, total) => total > 0 ? str.tostring(math.round(100 * wins / total, 1)) + "%" : "-"

// ‚Äî‚ÄîÂÖ•Âú∫Êé®ÈÄÅÔºàÂ§ßÈ•ºÔºâ‚Äî‚Äî
if barstate.isconfirmed and calcEnabled and callSig
    alert('{"msgtype":"text","text":{"content":"Â§ßÈ•º‰∫ã‰ª∂\\nÂêàÁ∫¶Ôºö' + syminfo.ticker +
          '\\nÂΩìÂâç‰ª∑Ê†ºÔºö' + str.tostring(close, format.mintick) +
          '\\nÊó∂Èó¥Ôºö' + fmtCN(time_close) +
          '\\nÂΩìÂâçKÁ∫øÔºö' + tfText +
          '\\n‰ø°Âè∑ÔºöÊ∂®üìàÔºàCALLÔºâ"}}', alert.freq_once_per_bar_close)

if barstate.isconfirmed and calcEnabled and putSig
    alert('{"msgtype":"text","text":{"content":"Â§ßÈ•º‰∫ã‰ª∂\\nÂêàÁ∫¶Ôºö' + syminfo.ticker +
          '\\nÂΩìÂâç‰ª∑Ê†ºÔºö' + str.tostring(close, format.mintick) +
          '\\nÊó∂Èó¥Ôºö' + fmtCN(time_close) +
          '\\nÂΩìÂâçKÁ∫øÔºö' + tfText +
          '\\n‰ø°Âè∑ÔºöË∑åüìâÔºàPUTÔºâ"}}', alert.freq_once_per_bar_close)

// ‚Äî‚ÄîÁªìÊûúÊ†áÁ≠æ & Êé®ÈÄÅÔºàÂ§ßÈ•ºÔºâ‚Äî‚Äî
if barstate.isconfirmed and calcEnabled
    if callDoneNow
        lblTxt = "CALL ÁªìÊûú: " + (callWinNow ? "Ëµ¢ ‚úÖ" : "‰∫è ‚ùå") +
                 "\nÂÖ•: " + str.tostring(callEntryN, format.mintick) + " @ " + fmtCN(time_close[holdBars]) +
                 "\nÂá∫: " + str.tostring(close,      format.mintick) + " @ " + fmtCN(time_close)
        label.new(bar_index, high, lblTxt, style=label.style_label_down, textcolor=color.white,
                  color=callWinNow ? color.new(color.green, 0) : color.new(color.red, 0))

        allTotNow = callTotal + putTotal
        allWinNow = callWins + putWins
        callWRs   = strWR(callWins, callTotal)
        putWRs    = strWR(putWins, putTotal)
        allWRs    = strWR(allWinNow, allTotNow)

        alert('{"msgtype":"text","text":{"content":"Â§ßÈ•º‰∫ã‰ª∂ÔºàÁªüËÆ°Ôºâ\\nÁ±ªÂûãÔºöCALL ' + (callWinNow ? 'Ëµ¢ ‚úÖ' : '‰∫è ‚ùå') +
              '\\nÂêàÁ∫¶Ôºö' + syminfo.ticker +
              '\\nÂÖ•Âú∫‰ª∑Ôºö' + str.tostring(callEntryN, format.mintick) + 'Ôºà' + fmtCN(time_close[holdBars]) + 'Ôºâ' +
              '\\nÂà∞Êúü‰ª∑Ôºö' + str.tostring(close,      format.mintick) + 'Ôºà' + fmtCN(time_close) + 'Ôºâ' +
              '\\nÂΩìÂâçKÁ∫øÔºö' + tfText +
              '\\n‚Äî‚Äî ÁªüËÆ°Ê±áÊÄª ‚Äî‚Äî' +
              '\\nCALLÔºö' + str.tostring(callWins) + '/' + str.tostring(callTotal) + 'Ôºà' + callWRs + 'Ôºâ' +
              '\\nPUT Ôºö' + str.tostring(putWins)  + '/' + str.tostring(putTotal)  + 'Ôºà' + putWRs  + 'Ôºâ' +
              '\\nÊÄªËÆ°Ôºö' + str.tostring(allWinNow) + '/' + str.tostring(allTotNow) + 'Ôºà' + allWRs   + 'Ôºâ"}}',
              alert.freq_once_per_bar)

    if putDoneNow
        lblTxt = "PUT ÁªìÊûú: " + (putWinNow ? "Ëµ¢ ‚úÖ" : "‰∫è ‚ùå") +
                 "\nÂÖ•: " + str.tostring(putEntryN, format.mintick) + " @ " + fmtCN(time_close[holdBars]) +
                 "\nÂá∫: " + str.tostring(close,     format.mintick) + " @ " + fmtCN(time_close)
        label.new(bar_index, low, lblTxt, style=label.style_label_up, textcolor=color.white,
                  color=putWinNow ? color.new(color.green, 0) : color.new(color.red, 0))

        allTotNow = callTotal + putTotal
        allWinNow = callWins + putWins
        callWRs   = strWR(callWins, callTotal)
        putWRs    = strWR(putWins, putTotal)
        allWRs    = strWR(allWinNow, allTotNow)

        alert('{"msgtype":"text","text":{"content":"Â§ßÈ•º‰∫ã‰ª∂ÔºàÁªüËÆ°Ôºâ\\nÁ±ªÂûãÔºöPUT ' + (putWinNow ? 'Ëµ¢ ‚úÖ' : '‰∫è ‚ùå') +
              '\\nÂêàÁ∫¶Ôºö' + syminfo.ticker +
              '\\nÂÖ•Âú∫‰ª∑Ôºö' + str.tostring(putEntryN, format.mintick) + 'Ôºà' + fmtCN(time_close[holdBars]) + 'Ôºâ' +
              '\\nÂà∞Êúü‰ª∑Ôºö' + str.tostring(close,     format.mintick) + 'Ôºà' + fmtCN(time_close) + 'Ôºâ' +
              '\\nÂΩìÂâçKÁ∫øÔºö' + tfText +
              '\\n‚Äî‚Äî ÁªüËÆ°Ê±áÊÄª ‚Äî‚Äî' +
              '\\nCALLÔºö' + str.tostring(callWins) + '/' + str.tostring(callTotal) + 'Ôºà' + callWRs + 'Ôºâ' +
              '\\nPUT Ôºö' + str.tostring(putWins)  + '/' + str.tostring(putTotal)  + 'Ôºà' + putWRs  + 'Ôºâ' +
              '\\nÊÄªËÆ°Ôºö' + str.tostring(allWinNow) + '/' + str.tostring(allTotNow) + 'Ôºà' + allWRs  + 'Ôºâ"}}',
              alert.freq_once_per_bar)

// ================= ‰∫åÈ•ºÔºàETHÔºâ‰ø°Âè∑‰∏éÁªüËÆ° =================
f_calc_sig() =>
    slow = maVariant(slowTyp, close, slowLen)
    fast = maVariant(fastTyp, close, fastLen)
    upT  = ta.rising(slow, dCandles) and fast > slow
    dnT  = ta.falling(slow, dCandles) and fast < slow
    md   = upT ? 1 : dnT ? -1 : 0

    rsiV = ta.rsi(close, rsiLength)
    bbB  = ta.sma(close, bb_length)
    dv   = ta.stdev(close, bb_length)
    bbH  = bbB + bb_mult * dv
    bbL  = bbB - bb_mult * dv

    rOK  = rsiV > rsiLower and rsiV < rsiUpper
    fwH  = ((close > open) and (not dFilter or md < 0)) ? rOK and (close > bbH) : false
    fwL  = ((close < open) and (not dFilter or md > 0)) ? rOK and (close < bbL) : false
    fbH  = ((not dFilter or md < 0) and fwH[1] and (not fwH)) ? rOK and (close[1] >= bbH[1]) : false
    fbL  = ((not dFilter or md > 0) and fwL[1] and (not fwL)) ? rOK and (close[1] <= bbL[1]) : false

    [fbL, fbH, close, time_close]   // ËøîÂõûÔºöCALL, PUT, Êî∂Áõò‰ª∑, Êî∂ÁõòÊó∂Èó¥ÔºàmsÔºâ

// ÈÄöËøá request.security Ëé∑Âèñ‰∫åÈ•º‰ø°Âè∑ÔºàÈªòËÆ§ÈöèÂõæË°®Ôºâ
var bool  ethReady = false
var bool  callSigE = false
var bool  putSigE  = false
var float closeE   = na
var int   tE       = na

if monitorEth
    [_callE, _putE, _closeE, _tE] = request.security(ethSymbol, workTf, f_calc_sig())
    callSigE := _callE
    putSigE  := _putE
    closeE   := _closeE
    tE       := _tE
    ethReady := true

// ÂÖ•Âú∫Êé®ÈÄÅÔºà‰∫åÈ•ºÔºâ
if monitorEth and ethReady and calcEnabled
    symName = str.replace(ethSymbol, "BINANCE:", "")
    if barstate.isconfirmed and callSigE
        alert('{"msgtype":"text","text":{"content":"‰∫åÈ•º‰∫ã‰ª∂\\nÂêàÁ∫¶Ôºö' + symName +
              '\\nÂΩìÂâç‰ª∑Ê†ºÔºö' + str.tostring(closeE) +
              '\\nÊó∂Èó¥Ôºö' + fmtCN(tE) +
              '\\nÂΩìÂâçKÁ∫øÔºö' + tfText +
              '\\n‰ø°Âè∑ÔºöÊ∂®üìàÔºàCALLÔºâ"}}', alert.freq_once_per_bar_close)
    if barstate.isconfirmed and putSigE
        alert('{"msgtype":"text","text":{"content":"‰∫åÈ•º‰∫ã‰ª∂\\nÂêàÁ∫¶Ôºö' + symName +
              '\\nÂΩìÂâç‰ª∑Ê†ºÔºö' + str.tostring(closeE) +
              '\\nÊó∂Èó¥Ôºö' + fmtCN(tE) +
              '\\nÂΩìÂâçKÁ∫øÔºö' + tfText +
              '\\n‰ø°Âè∑ÔºöË∑åüìâÔºàPUTÔºâ"}}', alert.freq_once_per_bar_close)

// ÁªìÊûúËØÑ‰º∞‰∏éÊé®ÈÄÅÔºà‰∫åÈ•ºÔºåÈÄíÊé®Á¥ØËÆ°Ôºâ
var int callTotalE = 0
var int callWinsE  = 0
var int putTotalE  = 0
var int putWinsE   = 0

if monitorEth and ethReady and calcEnabled
    callEntryE = callSigE ? closeE : na
    putEntryE  = putSigE  ? closeE : na

    callDoneNowE = callSigE[holdBars]
    putDoneNowE  = putSigE[holdBars]
    callEntryNE  = callEntryE[holdBars]
    putEntryNE   = putEntryE[holdBars]
    callWinNowE  = callDoneNowE and closeE > callEntryNE
    putWinNowE   = putDoneNowE  and closeE < putEntryNE

    if barstate.isconfirmed
        callTotalE := nz(callTotalE[1]) + (callDoneNowE ? 1 : 0)
        putTotalE  := nz(putTotalE[1])  + (putDoneNowE  ? 1 : 0)
        callWinsE  := nz(callWinsE[1])  + (callWinNowE  ? 1 : 0)
        putWinsE   := nz(putWinsE[1])   + (putWinNowE   ? 1 : 0)

        symName = str.replace(ethSymbol, "BINANCE:", "")

        if callDoneNowE
            allTotNowE = callTotalE + putTotalE
            allWinNowE = callWinsE  + putWinsE
            callWRsE   = strWR(callWinsE, callTotalE)
            putWRsE    = strWR(putWinsE,  putTotalE)
            allWRsE    = strWR(allWinNowE, allTotNowE)

            alert('{"msgtype":"text","text":{"content":"‰∫åÈ•º‰∫ã‰ª∂ÔºàÁªüËÆ°Ôºâ\\nÁ±ªÂûãÔºöCALL ' + (callWinNowE ? 'Ëµ¢ ‚úÖ' : '‰∫è ‚ùå') +
                  '\\nÂêàÁ∫¶Ôºö' + symName +
                  '\\nÂÖ•Âú∫‰ª∑Ôºö' + str.tostring(callEntryNE) + 'Ôºà' + fmtCN(timenow - (holdBars * tfSec * 1000)) + 'Ôºâ' +
                  '\\nÂà∞Êúü‰ª∑Ôºö' + str.tostring(closeE)      + 'Ôºà' + fmtCN(tE) + 'Ôºâ' +
                  '\\nÂΩìÂâçKÁ∫øÔºö' + tfText +
                  '\\n‚Äî‚Äî ÁªüËÆ°Ê±áÊÄª ‚Äî‚Äî' +
                  '\\nCALLÔºö' + str.tostring(callWinsE) + '/' + str.tostring(callTotalE) + 'Ôºà' + callWRsE + 'Ôºâ' +
                  '\\nPUT Ôºö' + str.tostring(putWinsE)  + '/' + str.tostring(putTotalE)  + 'Ôºà' + putWRsE  + 'Ôºâ' +
                  '\\nÊÄªËÆ°Ôºö' + str.tostring(allWinNowE) + '/' + str.tostring(allTotNowE) + 'Ôºà' + allWRsE  + 'Ôºâ"}}',
                  alert.freq_once_per_bar)

        if putDoneNowE
            allTotNowE = callTotalE + putTotalE
            allWinNowE = callWinsE  + putWinsE
            callWRsE   = strWR(callWinsE, callTotalE)
            putWRsE    = strWR(putWinsE,  putTotalE)
            allWRsE    = strWR(allWinNowE, allTotNowE)

            alert('{"msgtype":"text","text":{"content":"‰∫åÈ•º‰∫ã‰ª∂ÔºàÁªüËÆ°Ôºâ\\nÁ±ªÂûãÔºöPUT ' + (putWinNowE ? 'Ëµ¢ ‚úÖ' : '‰∫è ‚ùå') +
                  '\\nÂêàÁ∫¶Ôºö' + symName +
                  '\\nÂÖ•Âú∫‰ª∑Ôºö' + str.tostring(putEntryNE) + 'Ôºà' + fmtCN(timenow - (holdBars * tfSec * 1000)) + 'Ôºâ' +
                  '\\nÂà∞Êúü‰ª∑Ôºö' + str.tostring(closeE)     + 'Ôºà' + fmtCN(tE) + 'Ôºâ' +
                  '\\nÂΩìÂâçKÁ∫øÔºö' + tfText +
                  '\\n‚Äî‚Äî ÁªüËÆ°Ê±áÊÄª ‚Äî‚Äî' +
                  '\\nCALLÔºö' + str.tostring(callWinsE) + '/' + str.tostring(callTotalE) + 'Ôºà' + callWRsE + 'Ôºâ' +
                  '\\nPUT Ôºö' + str.tostring(putWinsE)  + '/' + str.tostring(putTotalE)  + 'Ôºà' + putWRsE  + 'Ôºâ' +
                  '\\nÊÄªËÆ°Ôºö' + str.tostring(allWinNowE) + '/' + str.tostring(allTotNowE) + 'Ôºà' + allWRsE  + 'Ôºâ"}}',
                  alert.freq_once_per_bar)

// ================= ÔºàÂõæ‰∏äÔºâËÉúÁéáË°®Ê†ºÔºöBTC / ETH / ÊÄª =================
callWR_B = callTotal  > 0 ? 100.0 * callWins  / callTotal  : na
putWR_B  = putTotal   > 0 ? 100.0 * putWins   / putTotal   : na
allTot_B = callTotal + putTotal
allWin_B = callWins  + putWins
allWR_B  = allTot_B  > 0 ? 100.0 * allWin_B  / allTot_B    : na

callWR_E = monitorEth and callTotalE > 0 ? 100.0 * callWinsE / callTotalE : na
putWR_E  = monitorEth and putTotalE  > 0 ? 100.0 * putWinsE  / putTotalE  : na
allTot_E = monitorEth ? callTotalE + putTotalE : na
allWin_E = monitorEth ? callWinsE  + putWinsE  : na
allWR_E  = monitorEth and allTot_E > 0 ? 100.0 * allWin_E / allTot_E : na

// ÊÄªËÆ°ÔºàBTC+ETHÔºâ
callWinsAll  = callWins + (monitorEth ? callWinsE : 0)
callTotalAll = callTotal + (monitorEth ? callTotalE : 0)
putWinsAll   = putWins  + (monitorEth ? putWinsE  : 0)
putTotalAll  = putTotal + (monitorEth ? putTotalE : 0)
allTot_All   = (callTotal + putTotal) + (monitorEth ? (callTotalE + putTotalE) : 0)
allWin_All   = (callWins  + putWins ) + (monitorEth ? (callWinsE  + putWinsE ) : 0)

callWR_All  = callTotalAll > 0 ? 100.0 * callWinsAll / callTotalAll : na
putWR_All   = putTotalAll  > 0 ? 100.0 * putWinsAll  / putTotalAll  : na
allWR_All   = allTot_All   > 0 ? 100.0 * allWin_All  / allTot_All   : na

var table tb = table.new(position.top_right, 4, 7, frame_color=color.new(color.white,85), border_width=1)
if barstate.islast
    table.cell(tb, 0, 0, "È°πÁõÆ", bgcolor=color.new(color.silver,85))
    table.cell(tb, 1, 0, "Â§ßÈ•º(BTC)")
    table.cell(tb, 2, 0, "‰∫åÈ•º(ETH)")
    table.cell(tb, 3, 0, "ÊÄªËÆ°")

    table.cell(tb, 0, 1, "ÁªüËÆ°Âë®Êúü(ÂàÜÈíü)", bgcolor=color.new(color.silver,85))
    table.cell(tb, 1, 1, str.tostring(holdMins))
    table.cell(tb, 2, 1, monitorEth ? str.tostring(holdMins) : "-")
    table.cell(tb, 3, 1, str.tostring(holdMins))

    table.cell(tb, 0, 2, "CALL ËÉúÁéá/ÂÆåÊàê", bgcolor=color.new(color.green,85))
    table.cell(tb, 1, 2, (na(callWR_B) ? "-" : str.tostring(math.round(callWR_B, 1)) + "%") + " / " + str.tostring(callTotal))
    table.cell(tb, 2, 2, monitorEth ? ((na(callWR_E) ? "-" : str.tostring(math.round(callWR_E, 1)) + "%") + " / " + str.tostring(callTotalE)) : "-")
    table.cell(tb, 3, 2, (callTotalAll>0 ? str.tostring(math.round(callWR_All,1)) + "%" : "-") + " / " + str.tostring(callTotalAll))

    table.cell(tb, 0, 3, "PUT ËÉúÁéá/ÂÆåÊàê",  bgcolor=color.new(color.red,85))
    table.cell(tb, 1, 3, (na(putWR_B) ? "-" : str.tostring(math.round(putWR_B, 1)) + "%") + " / " + str.tostring(putTotal))
    table.cell(tb, 2, 3, monitorEth ? ((na(putWR_E) ? "-" : str.tostring(math.round(putWR_E, 1)) + "%") + " / " + str.tostring(putTotalE)) : "-")
    table.cell(tb, 3, 3, (putTotalAll>0 ? str.tostring(math.round(putWR_All,1)) + "%" : "-") + " / " + str.tostring(putTotalAll))

    table.cell(tb, 0, 4, "ÊÄªËÉúÁéá/ÂÆåÊàê",   bgcolor=color.new(color.blue,85))
    table.cell(tb, 1, 4, (na(allWR_B) ? "-" : str.tostring(math.round(allWR_B, 1)) + "%") + " / " + str.tostring(allTot_B))
    table.cell(tb, 2, 4, monitorEth ? ((na(allWR_E) ? "-" : str.tostring(math.round(allWR_E, 1)) + "%") + " / " + str.tostring(allTot_E)) : "-")
    table.cell(tb, 3, 4, (allTot_All>0 ? str.tostring(math.round(allWR_All,1)) + "%" : "-") + " / " + str.tostring(allTot_All))

    table.cell(tb, 0, 5, "CALL Ëµ¢ / PUT Ëµ¢", bgcolor=color.new(color.teal,85))
    table.cell(tb, 1, 5, str.tostring(callWins) + " / " + str.tostring(putWins))
    table.cell(tb, 2, 5, monitorEth ? (str.tostring(callWinsE) + " / " + str.tostring(putWinsE)) : "-")
    table.cell(tb, 3, 5, str.tostring(callWinsAll) + " / " + str.tostring(putWinsAll))

    table.cell(tb, 0, 6, "ÂΩìÂâçÂë®Êúü", bgcolor=color.new(color.silver,85))
    table.cell(tb, 1, 6, tfText)
    table.cell(tb, 2, 6, monitorEth ? tfText : "-")
    table.cell(tb, 3, 6, tfText)

// ================= Êù°‰ª∂ÊèêÈÜíÔºàÂÖºÂÆπËÄÅÁî®Ê≥ïÔºâ =================
alertcondition(FastBreakHi, title="PUT (close)",  message="PUT")
alertcondition(FastBreakLo, title="CALL (close)", message="CALL")